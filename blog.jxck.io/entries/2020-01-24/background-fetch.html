<!DOCTYPE html>
<html lang=ja>
<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset=utf-8>
  <meta name=viewport content="width=device-width,initial-scale=1">

  <link rel=author    href=https://jxck.io/humans.txt>
  <link rel=manifest  href=/manifest.webmanifest>
  <link rel=alternate href=/feeds/atom.xml type=application/atom+xml title=blog.jxck.io>

  <link rel=canonical href="https://blog.jxck.io/entries/2020-01-24/background-fetch.html">
  <link rel=amphtml   href="https://blog.jxck.io/entries/2020-01-24/background-fetch.amp.html">
  <link rel=preload   type=font/woff2 as=font href=/assets/font/NotoSansCJKjp-Regular-Jxck-20200904.woff2 crossorigin>

  <script async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
  <script defer src=/assets/js/main.js></script>
  <script defer src=/assets/js/ga.js></script>
  <script defer src=/assets/js/highlight.pack.js></script>

  <link rel=icon             type =image/svg+xml sizes=any href=https://jxck.io/assets/img/jxck.svg>
  <link rel=icon             type =image/png sizes=256x256 href=https://jxck.io/assets/img/jxck.png>
  <link rel=apple-touch-icon type =image/png sizes=256x256 href=https://jxck.io/assets/img/jxck.png>

  <meta name=author              content=Jxck>
  <meta name=description         content="Podcast を PWA 対応するために、待望だった機能の 1 つが Background Fetch だ。これにより、通常 Range Request で取得するような、大きなファイルを事前にダウンロードしておくことができるようになる。この API と、 Service...">
  <meta name=keywords            content="background-fetch,service worker">
  <meta name=theme-color         content=#000000>

  <meta name=twitter:card        content=summary>
  <meta name=twitter:site        content=@jxck_>
  <meta name=twitter:url         content=https://blog.jxck.io/entries/2020-01-24/background-fetch.html>
  <meta name=twitter:title       content="Service Worker の Background Fetch によるメディアのキャッシュ | blog.jxck.io">
  <meta name=twitter:description content="Podcast を PWA 対応するために、待望だった機能の 1 つが Background Fetch だ。これにより、通常 Range Request で取得するような、大きなファイルを事前にダウンロードしておくことができるようになる。この API と、 Service...">
  <meta name=twitter:image       content=https://jxck.io/assets/img/jxck.png>

  <meta property=og:type         content=article>
  <meta property=og:url          content=https://blog.jxck.io/entries/2020-01-24/background-fetch.html>
  <meta property=og:title        content="Service Worker の Background Fetch によるメディアのキャッシュ | blog.jxck.io">
  <meta property=og:site_name    content=blog.jxck.io>
  <meta property=og:description  content="Podcast を PWA 対応するために、待望だった機能の 1 つが Background Fetch だ。これにより、通常 Range Request で取得するような、大きなファイルを事前にダウンロードしておくことができるようになる。この API と、 Service...">
  <meta property=og:image        content=https://jxck.io/assets/img/jxck.png>

  <script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://blog.jxck.io"
    },
    "headline": "Service Worker の Background Fetch によるメディアのキャッシュ | blog.jxck.io",
    "image": [
      "https://jxck.io/assets/img/jxck.png",
      "https://logo.jxck.io/jxck.1200x1200.png"
    ],
    "datePublished": "2020-01-24T08:00:00+08:00",
    "dateModified": "2020-09-06T08:00:00+08:00",
    "author": {
      "@type": "Person",
      "name": "Jxck",
      "image": "https://jxck.io/assets/img/jxck.png"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Jxck",
      "logo": {
        "@type": "ImageObject",
        "url": "https://logo.jxck.io/jxck.60x60.png",
        "height": 60,
        "width": 60
      }
    },
    "description": "Podcast を PWA 対応するために、待望だった機能の 1 つが Background Fetch だ。これにより、通常 Range Request で取得するような、大きなファイルを事前にダウンロードしておくことができるようになる。この API と、 Service..."
  }
  </script>

  <title>Service Worker の Background Fetch によるメディアのキャッシュ | blog.jxck.io</title>
  <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/body.css>
</head>
<body>
  <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/header.css>
  <header>
    <nav>
      <ul>
        <li><a href=https://blog.jxck.io      ><img width=30 height=30 loading=eager src=/assets/img/blog.svg   title=blog   alt="blog logo" class=logo></a>
        <li><a href=/searches                 ><img width=30 height=30 loading=eager src=/assets/img/search.svg title=search alt=search></a>
        <li><a href="https://blog.jxck.io/entries/2020-01-24/background-fetch.amp.html#development=1" aria-label="amp version">
                                               <img width=30 height=30 loading=eager src=/assets/img/amp.svg    title=amp    alt="amp version"></a>
        <li><a href=.                         ><img width=30 height=30 loading=eager src=/assets/img/up.svg     title=up     alt="move to parent directory"></a>
        <li><a href=/feeds/atom.xml           ><img width=30 height=30 loading=eager src=/assets/img/rss.svg    title=rss    alt="rss feed"></a>
        <li><a href=https://jxck.io/humans.txt><img width=30 height=30 loading=eager src=/assets/img/humans.svg title=humans alt=huamns.txt></a>
        <li><a href=https://jxck.io           ><img width=30 height=30 loading=eager src=/assets/img/jxck.svg   title=jxck   alt="jxck logo" class=logo></a>
      </ul>
    </nav>
  </header>

  <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/markdown.css>
  <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/main.css>
  <main>
    <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/info.css>
    <dl class=info>
      <div><dt>created_at</dt><dd><time class=created_at datetime=2020-01-24>2020-01-24</time></dd></div>
      <div><dt>updated_at</dt><dd><time class=updated_at datetime=2020-09-06>2020-09-06</time></dd></div>
      <div>
        <dt class=tags>tags</dt>
        <dd>
          <nav>
            <ul>
              <li><a href="/tags/background-fetch.html">background-fetch</a>
              <li><a href="/tags/service%20worker.html">service worker</a>
            </ul>
          </nav>
        </dd>
      </div>
      <div>
        <dt>toc</dt>
        <dd>
          <details class=info>
            <summary>headdings</summary>
            <nav>
              <ul>
                <li><a href=#intro>## Intro</a>
                <li><a href=#background-fetch>## background fetch</a>
                <li><a href=#range-request-と-cache-api>## Range Request と Cache API</a>
                <li><a href=#service-worker-での-range-request>## Service Worker での Range Request</a>
                <li><a href=#ブラウザにおける-rangepartial>## ブラウザにおける Range/Partial</a>
                <li><a href=#background-fetch-1>## Background Fetch</a>
                <li><a href=#api>## API</a>
                <li><a href=#backgroundfetch-registration>### backgroundFetch registration</a>
                <li><a href=#foreground-event>### foreground event</a>
                <li><a href=#abort>### abort()</a>
                <li><a href=#background-event>## background event</a>
                <li><a href=#cache-hit>## Cache HIT</a>
                <li><a href=#demo>## DEMO</a>
                <li><a href=#本サイトへの適用>## 本サイトへの適用</a>
                <li><a href=#next>## Next</a>
              </ul>
            </nav>
          </details>
        </dd>
      </div>
    </dl>

    <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/article.css>
    <article>
      <h1><a href=/entries/2020-01-24/background-fetch.html>Service Worker の Background Fetch によるメディアのキャッシュ</a></h1>
      <section>
        <h2 id="intro"><a href="#intro">Intro</a></h2>
        <p>Podcast を PWA 対応するために、待望だった機能の 1 つが Background Fetch だ。
        <p>これにより、通常 Range Request で取得するような、大きなファイルを事前にダウンロードしておくことができるようになる。
        <p>この API と、 Service Worker およびブラウザにおける Range Request/Partial Response の扱いについて記す。
      </section>
      <section>
        <h2 id="background-fetch"><a href="#background-fetch">background fetch</a></h2>
        <p>Podcast は大きな音声ファイルがメインコンテンツとなる。
        <p>PWA のキャッシュ戦略典型例としては
        <ul>
          <li>install 時に全てキャッシュする
          <li>request 発生時にキャッシュする
        </ul>
        <p>といった方法がある。
        <p>しかし、この方法は一般的な Podcast としては少し使いにくい。
        <ul>
          <li>install 時に全てのファイルをキャッシするのは現実的ではない
          <li>request が Range なのでキャッシュが生成しにくい
        </ul>
        <p>前者は分かりやすいだろう。後者は少し補足する。
      </section>
      <section>
        <h2 id="range-request-と-cache-api"><a href="#range-request-と-cache-api">Range Request と Cache API</a></h2>
        <p>音声の再生は、必ずファイルの先頭からリクエストするわけではなく、途中から聞く場合は途中からリクエストを行う。
        <p>また、全てのレスポンスが揃ってから開始するわけではなく、届いた順に再生する。
        <p>HTTP 上は Range Request と Partial Response が使われ、途中から再生するような場合以下のようになる。
        <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/pre.css>
        <pre><code translate="no">GET /mozaic-ep60.mp3 HTTP/1.1
Host: files.mozaic.fm
Range: bytes=54034432-</code></pre>
        <pre><code translate="no">HTTP/1.1 206 Partial Content
content-type: audio/mpeg
Content-Range: bytes 54034432-101797887/101797888
Content-Length: 47763456</code></pre>
        <p>つまり、 1 つの音声ファイルを取得するリクエスト/レスポンスが、 1 つとは限らないというわけだ。
      </section>
      <section>
        <h2 id="service-worker-での-range-request"><a href="#service-worker-での-range-request">Service Worker での Range Request</a></h2>
        <p>ところが onfetch で Range になるはずのリクエストを見てみると、レスポンスが必ず 200 で返ってきていることに気付く。
        <pre class=js><code translate="no">self.addEventListener(&#39;fetch&#39;, (e) =&gt; {
  e.respondWith((async () =&gt; {
    const req = e.request
    const res = await fetch(req)
    console.log(req, res) // status 200
    return res
  })())
})</code></pre>
        <p>最初は Service Worker が 206 を 200 に変えてしまうバグかと思ったが、 Content-Range もついてない。
        <p>もしやと思い、サーバ側のログを見ると、そもそも Range ヘッダが送られていない。
        <p>そもそも、 fetch を通すと Range Request が普通のリクエストとして送られているのだ。
        <p>最初に試したのが 4 年ほど前で、 Service Worker の初期の頃だったため、単に実装されてないだけろうと思い、実装されるのを待って漬けていた。
      </section>
      <section>
        <h2 id="ブラウザにおける-rangepartial"><a href="#ブラウザにおける-rangepartial">ブラウザにおける Range/Partial</a></h2>
        <p>以下のブログが出て初めて、実装ではなく仕様の問題だということがわかった。
        <ul>
          <li><a href="https://jakearchibald.com/2018/i-discovered-a-browser-bug/">I discovered a browser bug - JakeArchibald.com</a>
        </ul>
        <p>結論から言うとこうだ。
        <blockquote>
          <p>They&rsquo;re standardised in HTTP, but not by HTML. We know what the headers look like, and when they should appear, but there&rsquo;s nothing to say what a browser should actually do with them.
          <p>&mdash; <cite><a href="https://jakearchibald.com/2018/i-discovered-a-browser-bug/#range-requests-were-never-standardised">https://jakearchibald.com/2018/i-discovered-a-browser-bug/#range-requests-were-never-standardised</a></cite>
        </blockquote>
        <ul>
          <li>Range/Partial の仕様はあくまで HTTP の仕様
          <li>WHATWG において、それらがブラウザでどう扱われるかは、標準化されてない
          <li>
            <code translate="no">&lt;audio&gt;</code> / <code translate="no">&lt;video&gt;</code> などで Range を使うのはブラウザがそう実装してるだけ
          </li>
          <li>Service Worker/Cache のような API でどうするかは決まってない
        </ul>
        <p>つまり、 <em>Service Worker はそもそも Range/Partial には対応してない</em> というか標準化されてないと言って良いだろう。
        <p>それでも、 200 では取得できるため、全体が得られればキャッシュは可能で、 Safari などには 206 に置き換えて返すこともできる。
        <p>しかし、途中までしかキャッシュできてない状態でオフラインになると、途中で再生が止まるフラストレーションが溜まるだけだ。
        <p>なら Podcast アプリで聞いたほうが体験が良いということになる。
        <p>PWA で理想的な Podcast アプリを実現するのは難しそうだ。と諦めてから 4 年近く経った。
      </section>
      <section>
        <h2 id="background-fetch-1"><a href="#background-fetch-1">Background Fetch</a></h2>
        <p>Podcast のアプリは基本的に、ネットワークがある間にダウンロードを完了し、地下鉄などを移動する際に聞ける状態になっているだろう。
        <p>これと同じことが可能になるのが Background Fetch だ。
        <p>Service Worker に fetch を Task として追加し、バックグラウンドで実行させる。これは大きなファイルをブラウザでダウンロードしているときと同じような UX となる。
        <p>もちろん、取得が終われば結果を 1 つの大きな Response として取得できるため、それをそのまま Cache API で保存すれば良い。分割されてないため Cache HIT も普通にできる。
        <p>これを用いると Podcast アプリと近い UX を実現できるのだ。
      </section>
      <section>
        <h2 id="api"><a href="#api">API</a></h2>
        <section>
          <h3 id="backgroundfetch-registration"><a href="#backgroundfetch-registration">backgroundFetch registration</a></h3>
          <p>取得したい URL とオプションを登録する。
          <p>ID はそのタスク自体を識別するために登録し、もし同じ ID のタスクがある状態で再登録しようとすると例外が出る。
          <p>また、ダウンロード対象を複数登録して同時にダウンロードさせることができる。
          <pre class=js><code translate="no">const id   = &#39;ep01&#39;
const mp3  = &#39;https://files.example.com/ep01.mp3&#39;
const html = &#39;https://files.example.com/ep01.html&#39;
const option = {
  title: &#39;title of download&#39;,
  downloadTotal: 65535, // size
  icons: [{src: &#39;logo.png&#39;, sizes: &#39;256x256&#39;, type: &#39;image/webp&#39;}]
}
const registration = await navigator.serviceWorker.ready
const task = await registration.backgroundFetch.fetch(id, [html, mp3], option)</code></pre>
        </section>
        <section>
          <h3 id="foreground-event"><a href="#foreground-event">foreground event</a></h3>
          <p>ダウンロードの進捗は window 側で progress イベントで上がる
          <pre class=js><code translate="no">task.addEventListener(&#39;progress&#39;, (e) =&gt; console.log(e.downloaded))</code></pre>
        </section>
        <section>
          <h3 id="abort"><a href="#abort">abort()</a></h3>
          <p>中断は API から可能であり、 <code translate="no">abort()</code> を呼べば task が終了する。
          <pre class=js><code translate="no">task.abort()</code></pre>
          <p>ただし、 Pause/Resume は API がなく、<a href="https://github.com/WICG/background-fetch/issues/38">提案</a> はされてるが、その UI は OS 側が提供するというスタンスだ。
        </section>
      </section>
      <section>
        <h2 id="background-event"><a href="#background-event">background event</a></h2>
        <p>Service Worker 側では以下のイベントが上がる。
        <ul>
          <li>backgroundfetchsuccess
          <li>backgroundfetchfail
          <li>backgroundfetchabort
          <li>backgroundfetchclick
        </ul>
        <pre class=js><code translate="no">// ダウンロード完了
self.addEventListener(&#39;backgroundfetchsuccess&#39;, (e) =&gt; {
  e.waitUntil(async function() {
    try {
      // 結果を取り出す
      const id = e.registration.id
      const record = await e.registration.match(id)

      // キャッシュ対象
      const request = record.request
      const response = await record.responseReady

      // キャッシュ追加
      const cache = await caches.open(CACHE_NAME)
      await cache.put(request.url, response)

      // 通知
      await e.updateUI({ title: &#39;download finished&#39; })
    } catch (err) {
      console.error(err)
      e.updateUI({ title: `download failed ${e.registration.id}` })
    }
  }())
})

// download タスクをクリック
self.addEventListener(&#39;backgroundfetchclick&#39;, (e) =&gt; {
  e.waitUntil(async function() {
    const id = e.registration.id
    // 該当ページを開く
    clients.openWindow(`https://files.example.com/${id}.html`)
  }())
})

self.addEventListener(&#39;backgroundfetchfail&#39;, (e) =&gt; {
  // 特に何もする必要ないっぽい
  console.error(e)
})

self.addEventListener(&#39;backgroundfetchabort&#39;, (e) =&gt; {
  // 特に何もする必要ないっぽい
  console.error(e)
})</code></pre>
        <p>fail/abort は、タスクが消えるため特にリソースの開放などは必要なさそうだ。
      </section>
      <section>
        <h2 id="cache-hit"><a href="#cache-hit">Cache HIT</a></h2>
        <p>キャッシュは Range などを気にする必要もなく普通に返せば良い。
        <p>実際に <code translate="no">&lt;audio&gt;</code> タグは途中からでも普通に再生できた。
        <pre class=js><code translate="no">// ダウンロードしたものを返す
self.addEventListener(&#39;fetch&#39;, (e) =&gt; {
  e.respondWith(async function() {
    const cachedResponse = await caches.match(e.request.url)
    if (cachedResponse) {
      // cache hit
      return cachedResponse
    } else {
      // fallback to fetch
      return fetch(e.request)
    }
  }())
})</code></pre>
      </section>
      <section>
        <h2 id="demo"><a href="#demo">DEMO</a></h2>
        <p>動作するデモを以下に用意した。
        <ul>
          <li><a href="https://labs.jxck.io/service-worker/background-fetch/">https://labs.jxck.io/service-worker/background-fetch/</a>
        </ul>
      </section>
      <section>
        <h2 id="本サイトへの適用"><a href="#本サイトへの適用">本サイトへの適用</a></h2>
        <p>本サイトというか、適用先は mozaic.fm になる。
        <p>すでにコードはある程度できているが、まだ Storage Quota に達した時の挙動がよくわかってないため、もう少しエッジケースを潰せたら入れたい。
      </section>
      <section>
        <h2 id="next"><a href="#next">Next</a></h2>
        <p>ところが、 Podcast アプリなら、ユーザが操作してないときに自動でダウンロードしておきたい。
        <p>ネットワークに繋がっている場合、定期的にサーバに RSS を問い合わせ、更新があれば fetch する。
        <p>ここでもう 1 つ待望だった API の <a href="https://github.com/WICG/periodic-background-sync">Periodic Background Sync</a> が利用できるだろう。
        <p>また、今回の保存先はあくまでもキャッシュなので、キャッシュが増えればいずれ消える。
        <p>そこでより積極的に保存を考える場合は File API も考慮できるだろう。
        <p>次回はそれらを解説したい。
      </section>
    </article>
  </main>
  <hr>

  <link rel=stylesheet property=stylesheet type=text/css href=/assets/css/footer.css>
  <footer>
    <p class=copyright><small>Copyright &copy; 2016 <a href=/>Jxck</a>. All Rights Reserved.</small> See <small><a href=/policies/site.html>Site Policy</a> and <a href=/policies/privacy.html>Privacy Policy</a>.</small></p>
    <ins class=adsbygoogle data-ad-layout=in-article data-ad-format=fluid data-ad-client=ca-pub-2902784829138215 data-ad-slot=9735419796></ins>
  </footer>
</body>
</html>