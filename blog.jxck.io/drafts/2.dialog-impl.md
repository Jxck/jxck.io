# Dialog/Popover (2)

前回は dialog の概要を話したので、今回は実装編についてみていく。

## `<dialog>` 要素

`<dialog>` は、デフォルトでは不可視な要素となっている。これを表示するには `open` 属性を用いる。

```html
<dialog open>
  <div>
    <h1>Hello Dialog</h1>
  </div>
</dialog>
```

TODO: 図

これはこのままでは閉じることもできない。しかし、 JS を書かなくても HTML だけで閉じることができる。

```html
<dialog open>
  <div>
    <h1>Hello Dialog</h1>
    <form method="dialog">
      <button type="submit">Confirm</button>
    </form>
  </div>
</dialog>
```

このように `<form method=dialog>` を `<dialog>` の中に書くと、その submit は dialog を submit したことになるので、 dialog を閉じることになる。これにより、ユーザに何かを確認させ、インタラクションを求めるユースケースで利用できる。

インタラクションの結果を取得する場合は JS が必要だ。その場合も `<dialog>` を JS から動的に作るよりは、先に `<dialog>` を open 属性なしに HTML 上に配置しておき、その `show()/close()` を JS で操作するのが基本になる。

閉じるだけではなく、開く方も JS なしでできるが、それについては後述する。


## aria-label / aria-labelledby

WAI-ARIA では `role=modal` に対して、 `aria-label` / `aria-labelledby` を使ってアクセシブルな名前を入れることが推奨されている。

- Accessible Rich Internet Applications (WAI-ARIA) 1.3
  - https://w3c.github.io/aria/#dialog

`<h1>` を参照する場合は以下のようになる。

```html
<dialog aria-labelledby="dialog_name">
  <div>
    <h1 id="dialog_name">Hello Dialog</h1>
    <form method="dialog">
      <button type="submit">Confirm</button>
    </form>
  </div>
</dialog>
```

## show()/showModal()

とりあえず開くとこう。

```html
<dialog aria-labelledby="dialog_name">
  <div>
   <h1 id="dialog_name">Hello Dialog</h1>
   <form method="dialog">
      <button type="submit">Confirm</button>
    </form>
  </div>
</dialog>
<button id=show>dialog.show()</button>
<button id=showModal>dialog.showModal()</button>
<script>
  const $ = document.querySelector.bind(document)
  const $$ = document.querySelectorAll.bind(document)
  EventTarget.prototype.on = EventTarget.prototype.addEventListener
  $('#show').on('click', (e) => {
    $('dialog').show()
  })
  $('#showModal').on('click', (e) => {
    $('dialog').showModal()
  })
</script>
```

まず `show()` で開くとさっきと同じ、 `<dialog open>` した状態になって Dialog が開く。

TODO: `show()` で dialog を開く画像

これは単に non-modal な Dialog が open してるだけなので、後にあるテキストの選択や、ボタンクリックができる。また、この時別の `<dialog>` を show しても同時に表示できる。これは、全く排他的な操作をしてないことを意味する。

Accessibility Tree を確認すると Role が `dialog` になっていることが確認できるだろう。

TODO: role: dialog, modal: false になっている画像

これを、 `showModal()` で開いたらこうなる。

TODO: showModal() で Modal Dialog を開く

背景が薄くグレーになるのは、 `:backdrop` のデフォルト CSS があたってるからだ。

TODO: chrome の backdrop スタイルの図

かつ、後ろには `inert` が適用されているため、背景のボタンクリックや、テキスト選択はできない。ちなみに、 body に inert つけると dialog も inert になるからどうするのかなと思ったら、 inert 属性が body に付くとかそういうわけではないっぽいね。(仕様上は document を "blocked by the modal dialog" にすると書いてある。)

non-Modal と異なり Modal は同時に一つしか開けない。

Accessibility Tree もこうなる。

TODO: role: dialog, modal: true になっている


## フォーカスの確認

次は、それぞれのフォーカスの挙動を確認する。

開いてたボタンにフォーカスを移し、キーボードで開くと違いがわかる。

共通してるのは以下だ。

- focus した button を Enter で開いたら、 focus が dialog 内の button に移る。
- dialog の button で close したら、その前のボタンに focus が戻る。

これにより、 Dialog を開いてもフォーカスが残るとか、閉じたらフォーカスが迷子になるみいたなことはなくなっている。

相違点は

- non-Modal: Modal の外にも focus が移動できる
- Modal: Modal 以外には focus が出ない。(ブラウザ UI 側には出られる)

これにより、 Modal を開いた状態で、余計なところに focus がいくみたいなことがなくなる。

なお、今回は `<dialog>` に `<button>` が一個しかないから、ここに自動で focus が移るが、特に Modal dialog はデフォルトでどこにフォーカスを移すのかは非常に重要で、仕様でどうするかも結構揉めた。


TODO: scroll に focus するのもここ


そして、仕様では「どこにフォーカスすべきかを autofocus で指定するのが推奨」となった。
結果 `showModal()` は `autofocus` を尊重するので、基本は `autofocus` を指定する方が良いだろう。今回の場合は `<button>` だろう。

```html
<dialog>
  <div>
    <h1>Hello Dialog</h1>
    <form method="dialog">
      <button autofocus type="submit">Confirm</button>
    </form>
  </div>
</dialog>
```

## Close と returnValue

Dialog を閉じるなら form じゃなくて close() を呼んでも閉じる。ちなみに、 「open 属性を消す」ことは modal が「消える(hidden)」にはなるけど、「閉じる(close)」の意味にはならない(close イベントも発火しない)ので、必ず close() を使って閉じよう。

ダイアログを閉じるとき、ユーザは何かしらのインタラクションを行ったはずだから、その結果、例えば「同意したかどうか」とか「何を選択したか」とか、が値として欲しいことになるね。(これは showModalDialog() 時代からそうだったね)

これは、 JS の場合は dialog.close() に渡した文字列がそのまま取得できる。

`$dialog.close("accept")$dialog.retunValue// "accept"`

これは、 `<form>` を使った場合に submit された結果も取得できるから、どちらかというとその使い方が多いかな。

## backdrop をクリックしたら閉じる

ちょっとしたテクニック。dialog の要件として「背景(backdrop)をクリックしたら閉じたい」ってのがあるあるだと思うんだけど、これは Modal の場合は「backdrop 含め、どこをクリックしても dialog がクリックされたことになる」という性質があるんだ。

`dialog.on('click',(e)=>{// 画面のどこクリックしても発火console.log(e.target)// dialog})`
Open image-20240610-204405.png![image-20240610-204405.png](blob:https://sharedoc.atlassian.net/3ea7cf35-4288-4698-9d8f-90b52b673956#media-blob-url=true&id=8f3bd9c3-c729-4f0a-8b7b-859d0d784f95&collection=contentId-3473015166&contextId=3473015166&width=432&height=333&alt=image-20240610-204405.png)

Modal は画面のどこをクリックしても dialog で発火

そこで、 dialog の padding を 0 にして、下の div が dialog の内側いっぱいに表示されている状態にしよう。(わかりやすく div は色をつけてる)

`<style>  dialog {
    padding: 0;
    div {
      padding: 1rem;
      background-color: red;
    }
  }
</style><dialog><div><h1>Hello Dialog</h1><formmethod="dialog"><buttonautofocustype="submit"value="confirm">Confirm</button><buttontype="cancel"value="cancel">Cancel</button></form></div></dialog>`

この状態で showModal() したあとは、 dialog の領域をクリックしても div がクリックされたことになるね。

Open image-20240610-205916.png![image-20240610-205916.png](blob:https://sharedoc.atlassian.net/d14d3bd4-200b-48ee-969f-ff62e6b12d79#media-blob-url=true&id=45030ded-b327-4f8a-9079-39513a2bfa1d&collection=contentId-3473015166&contextId=3473015166&width=353&height=284&alt=image-20240610-205916.png)

dialog 領域のクリックが div で発生する

これを利用して、 dialog の中には小要素を敷き詰めて、 dialog 自体をクリックした時は click が dialog で発火しないようにする。こうすると、 dialog 領域の外をクリックしたら target/currentTarget が同じ dialog だけど、中の場合は target が小要素のどれかになるので、これで分岐できるんだね。

`$('dialog').on('click',(e)=>{// dialog 背景含めて全体がフック対象const{target, currentTarget}= e
console.log({target, currentTarget})if(e.target=== e.currentTarget){// 両方 dialog 自身なのは backdrop のみになる$('dialog').close()}})`

## cancel/close イベント

イベントは基本この二つ。

例えば、さっきの `<form method=dialog>` を submit した時の値が欲しいなら、 `button[value]` を使ってこんな感じになる。ちなみに cancel() はないから、 cancel も `button[type=cancel]` で行えるよ。

`<dialog><div><h1>Hello Dialog</h1><formmethod="dialog"><buttonautofocustype="submit"value="confirm">Confirm</button><buttontype="cancel"value="cancle">cancel</button></form></div></dialog><script>  // ...
  $('dialog').on('close', (e) => {
    console.log(e.target.returnValue) // close
  })
  $('dialog').on('cancel', (e) => {
    console.log(e.target.returnValue) // cancel
  })
</script>`

これ以外、例えば何かを input させたり、 select させたりする場合、その結果は JS で集めて `close()`に渡すしかない点に注意ね。

## dialog は scroll させない

これも仕様にまんま書いてあるんだけど、 たくさんのテキストを表示して、 dialog 自体がスクロール可能になることは望ましくないのでやめようという推奨がある。

もちろん、規約みたいな長いテキストは別ページでリンクみたいなのでもいいんだけど、もし長い文章を入れるなら、一個下の要素で scroll させようっていう意味。

`<dialogstyle="height: 80vh;"><divstyle="overflow: auto; height: 60vh;"autofocus><p>めっちゃ</p><p>長い</p><p>規約</p></div><formmethod="dialog"><buttontype="submit"value="agree">Agree</button><buttontype="submit"value="disagree">Disagree</button></form></dialog>`

あくまで div がスクロールしてるから dialog 自体はスクロールしないってことね。

そして、規約だから agree か disagree で結果が返るね。

あと、この場合デフォルトでは scroll する div にフォーカスがあたるけど、さっき言ったように focus は明示的に指定すべきだからマニュアルで autofocus をつけるのも忘れずに。

## キーボード操作

ボタンを置く以外に、キーボード操作の対応もネイティブで行われているよ。これは、そういうキャンセルやクローズを意味する操作を自動でフックしてくれる CloseWatcher ってのが使われているんだね。

non-modal は他が操作できるからキーボードには反応しないけど、他を止めちゃう modal な dialog は CloseWatcher が効いてるので、 ESC で閉じたりできます。 Android は背面タップで閉じるらしいけど持ってないから試せない。

showModal の方で ESC 押すと、 cancel → close の順でイベントが発火するよ。

## dialog の使い所

さて、一通り確認したところで使い方を確認していこう。

例えば、規約を表示してそこへの同意を取得するとかね。で、閉じたらその結果 returnValue で取得して処理を分岐しつつ継続するってわけだね。

その上で

- ユーザをブロックして、処理が終わらない限り先には進めない => Modal Dialog

- ユーザをブロックはしない、けどどこかで処理は求めたい => non-Modasl Dialog

って使い分けだね。

例えば、ログインしないと先に進めないなら、 Modal Dialog にログインフォームが入るかもしれない。

でも Cookie への同意を画面の下に出すんだったら、 non-Modal で出す。みたいな。

このように、インタラクションを求めるのが <dialog> なんだ。 <dialog> が role=dialog の要素だってことが非常に重要。これは「ユーザに対して何かインタラクションを求めていますよ」そして、「そのインタラクションが終わったら閉じる」ってのが基本。

もし、単なる「変更が保存されました」とか「わからなかったら下のヘルプを使ってね」みたいなものは、 Dialog でやることじゃないんだ。 Top Layer に表示できるからって、浮かび上がるなんにでも Dialog を使うってのは間違い。

そして、逆に「ユーザにインタラクションを求める Modal Dialog UI」を dialog を使わずに実装するのも、今後は良くないことになるね。フォーカス管理も、 inert も、Close Watcher も、標準になってなければ完璧に実装するのが難しい機能で、これがきちんと実装できなければ、特にアクセシビリティの文脈では問題になるんだ。

支援技術を使ってる人が、そもそも dialog が開いてることにちゃんと気づけなかったり、dialog が開いて操作ができなくなったけど、何が起こったのかわからななかったり、操作できないはずのところに focus が飛んで想定外の操作しちゃったり、 ESC が辺に奪われてて何かができなくなったり、開いて閉じたら focus が迷子になったり etc etc etc

でも、 dialog をちゃんと使えば、支援技術には role=dialog なものが開いたことが伝わる。操作もプラットフォームがきちんとサポートしてくれる。

そういう意味で、本当に重要な要素の一つなんだね。

でもでも、なんか dialog って用途限られてるよね。

もっとカジュアルに「ポコッ」とか「ヒョコッ」って出るメッセージとかを、 Top Layer 表示したりできると嬉しいよね。 CloseWatcher も inert も backdrop も使いたい、でも dialog ではない。

そんな時に、、、いよいよ本題に入っていくよ！
